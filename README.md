# Glossary-of-Tech-Terms
## 10 Key Scrum Terms
### Burndown Charts:
_Burndown charts are a good way to show what work you have remaining over time._

_The chart is broken down into the two axis - Y axis and X axis. The Y axis = Work remaining and X axis = Time._

_The work remaining should fluctuate and eventually decrease in amount._ 

### Daily Scrum Meeting:
A daily scrum meeting is a fifteen-minute meeting where each team member will answer three simple questions:

1. "What have I done since the last Scrum meeting? (i.e. yesterday)"

2. "What will I do before the next Scrum meeting? (i.e. today)"

3. "What prevents me from performing my work as efficiently as possible?"

The ScrumMaster will make sure that all members have sidebar meetings for any discussions that go too far outside of these constraints.

The Scrum literature recommends that these meetings take place first thing in the morning as soon as all team members are present.

### Impediments:
Anything that prevents a team member from performing work as efficiently as possible is an impediment.

Each team member has an opportunity to announce impediments during the daily Scrum meeting. 

The ScrumMaster is charged with ensuring impediments get resolved. 

ScrumMasters often arrange sidebar meetings when impediments cannot be resolved on the spot in the daily Scrum meeting.

### Product Backlog:
Product backlog is the requirements for a system, expressed as a prioritized list of product backlog items. 

While there are multiple inputs to the product backlog, it is the sole responsibility of the product owner to prioritize the product backlog.

### Product Owner Role:
In Scrum, a single person must have final authority representing the customer's interest in backlog prioritization and requirements questions.

This person must be available to the team at any time, but especially during the sprint planning meeting and the sprint review meeting.

Challenges of being a product owner:

- Resisting the temptation to "manage" the team. The team may not self-organize in the way you would expect it to. This is especially challenging if some team members request your intervention with issues the team should sort out for itself.

- Resisting the temptation to add more important work after a Sprint is already in progress.

- Being willing to make hard choices during the sprint planning meeting.

- Balancing the interests of competing stakeholders.

### Release Burnout Chart:
In Scrum, the release burndown chart is a "big picture" view of a release's progress. It shows how much work was left to do at the beginning of each sprint comprising a single release. The scope of this chart is a single release; however, a product burndown chart spans all releases.

### Scrum Roles:
There are three essential roles in any Scrum project:

1. Product Owner
2. ScrumMaster
3. Team

### ScrumMaster Role:
The ScrumMaster is a facilitator for the team and product owner. Rather than manage the team, the ScrumMaster works to assist both the team and product owner in the following ways:

- Remove the barriers between the development and the product owner so that the product owner directly drives development.
- Teach the product owner how to maximize return on investment (ROI), and meet his/her objectives through Scrum.
- Improve the lives of the development team by facilitating creativity and empowerment.
- Improve the productivity of the development team in any way possible.
- Improve the engineering practices and tools so that each increment of functionality is potentially shippable.
- Keep information about the team's progress up to date and visible to all parties.

### Sprint:
An iteration of work during which an increment of product functionality is implemented. By the book, an iteration lasts 30 days. This is longer than in other agile methods to take into account the fact that a functional increment of product must be produced each sprint.

The sprint starts with a one-day sprint planning meeting. Many daily Scrum meetings occur during the sprint (one per day). At the end of the sprint we have a sprint review meeting, followed by a sprint retrospective meeting.

During the sprint, the team must not be interrupted with additional requests. Guaranteeing the team won't be interrupted allows it to make real commitments it can be expected to keep.

### Team:
A team (or "Scrum team") is optimally comprised of seven plus or minus two people.

For software development projects, the team members are usually a mix of software engineers, architects, programmers, analysts, QA experts, testers, UI designers, etc. This is often called "cross-functional project teams". Agile practices also encourage cross-functional team members.

During a sprint, the team self-organizes to meet the sprint goals. The team has autonomy to choose how to best meet the goals, and is held responsible for them. The ScrumMaster acts as a guardian to ensure that the team is insulated from the product owner.

### Velocity:
In Scrum, velocity is how much product backlog effort a team can handle in one sprint. This can be estimated by viewing previous sprints, assuming the team composition and sprint duration are kept constant. It can also be established on a sprint-by-sprint basis, using commitment-based planning.

Once established, velocity can be used to plan projects and forecast release and product completion dates.

How can velocity computations be meaningful when backlog item estimates are intentionally rough? The law of large numbers tends to average out the roughness of the estimates.
## Other Terms:
### Algorithm
An algorithm is a list of rules to follow in order to solve a problem. Algorithms can perform calculations, data processing and automated reasoning tasks. They need to have their steps in the right order otherwise it would be like reading instructions in the incorrect order. An example of an algorithm is a Flow chart.
#### Implementation of an algorithm:
An algorithm is a list of rules or easier to understand, a step by step guide to what needs to happen. In order to implement an algorithm you just simply need to follow the steps or stages in which you want the application to run, for instance before starting any new code for an application you should break it down into steps of what happens, once you have outlined the steps you would then show this through a flow chart, the flow chart will then help when you start the code as it gives you a starting point as well as milestones when creating the code.
#### Relationship between the written algorithm and the code variant.
The relationship betweent the written algorithm and the code variant is that they both have specific steps and a set route in which they are going to acheive the same outcome. the written code is used in order for the developer to create the code variant.
### Pseudocode
A detailed yet readable description of what a computer program or algorithm must do. Pseudocode is an informal high-level description of the operating principle of a computer program or other algorithm.
### Debugging
Debugging is the process of finding and resolving defects or problems within the program that prevent correct operation of computer software or a system. In order to prevent incorrect operations of a system or software, debugging is used to find and resolve bugs or defects. 

The process of debugging helps software developers and companies to prevent problems, whilst doing this process though they are making the software more secure and robust. They are doing this by ironing out any underlying problesm with the code that could potentially cause an issue whilst using application. Typically the developer will be able to locate the source of the problem through using a program or feature where they run the code and at the exact time the application stops it will let the developer know what line of code was running and therefore it gives the developer the ability to know where abous the problem(s) are. By doing this we have made the software more secure as we would find problems within the code and fixed them so that there are no future holes. We would have also made the software more robust by doing debugging, this would help as we can test to make sure the software will continue to work multiple times without failing.

#### Debugging available in an IDE:
The IDE that I am going to look at is REPL.it, I personally used this IDE to code my first 3 projects, it was very helpful to me as a beginner as it showed exactly the line of code where i made a mistake or even missed something. It did this by showing in the console to the right in red text the problem and what the problem is as well as where it is. Usually within an IDE the software or application will prompt the user when they have made a mistake or when the code does not run as intendid. 
#### Examples of debugging tools/abilities:
* Breakpoints.
* Step into libraries
* Run, Step Over/Into/Out.
* View the call stack.
* List name and contents of variables in local/global scope.
* Hover over variable to show contents.
* Inspect or edit variable contents.
* View structure of objects.

### Coding Standards
Guideline for specific languages, e.g. Indentations, variable names, comments
### API
In computer programming, an application programming interface is a set of subroutine definitions, protocols, and tools for building application software.
### Programming paradigm
Programming paradigms are a way to classify programming languages based on their features. Languages can be classified into multiple paradigms.
### Procedural:
Procedural programming is structured into procedures. A procedure is a sequence of commands to be executed. Any procedure can be called from any point within the general program, including other procedures or even itself. 
### Event Driven Paradigm: 
Event-driven programming is a programming paradigm in which the flow of program execution is determined by events. These 'events' could consist of a user action such as a click or even a key being pressed. An event driven program is designed to detect events as they occur and then deal with them.
### Object Orientated:
This paradigm models problems in terms of entities called objects that have attributes and behaviours. these interact with other entities using message passing(calling methods on other entetites). These 'objects' may contain data in the form of fields, these are often known as attributes as well as code. This paradigm features objects that can access and modify data fields of the object that they are associated with. An object can also be defined as an instance, this instance is the blueprint.
### Relationship between paradigms:
All three of these paradigms are trying to do the same thing which is to help impliment some form of solution to the problem. The difference between them is how they solve the problem. All three contain functions however they all have different ways of them being implimented. Procedural calls the functions, Event driven ties the function to an 'event' and Object orientated ties the function to an object through class and other methods.
## Programming steps/building an application:
### 1. Metting the client:
The very first thing that you will do will be meet with the client that has hired you to undertake the task. From the initial meeting they will pitch their idea or proposal to you and you will take notes whilst also throwing ideas and questions their way to gain a better understanding. This initial process allows the client and the team to all get a unified understanding of what they want the final product to look like.
### 2. Clarify/Define the Language and IDE:
You will want to start by selecting a programming language to use, this is the language that you will write your project in. each language is different so it is important you select the right one for what you need. You will then want to chose an IDE to use, an IDE is a program or area where you will write your code. Some IDE's will have a debugging feature and possibly a preview of the code so that you can get a live view of what you're making.
### 3. Design the Program:
Within the design process you will need to create certain design documentation to help you with the project. The first thing that you will need to start with will be a flow chart, this will help you to make a step by step guide to how your code works. The second will be storyboards, this will help you turn your ideas into actual designs. You can then use your flow chart to help you map your storyboard, it helps by showing you which steps will go one after the other.
### 4. Code the Program:
In this stage, you will be using the IDE that you selected earlier and the language you chose to start your code. You will make sure at this stage that everything you plan to do is right for the clients needs. You will use the flow chart from your design documentation to help make sure that you are following the correct steps for your code.
### 5. Test the Program:
Throughout the coding process you will need to run regualr tests to make sure that the code you're typing is correct or that it works, if you have a good IDE then it will usually advise you if there are mistakes or problems with your code, however if this is not the case then you will need to find alternate ways to troubleshoot the code. This can be done by running the code as intended e.g. opening it in a browser or even in a third party software/program to see if the correct features load.
### 6. Document and Maintain:
Throughout the process of creating your working program for a client you should be documenting everything so that if they ask for evidence or you need to go back and see where you went wrong you will be able too. Documentation also helps to provide evidence to the client to show how hard or how long you spent working on the project.
### 7. Shipping/Hand over:
Once you have finished building the project and you have tested it and it works, it is time to hand it over to the client and make sure that they are happy with the final product. once they are happy then business is done.
### Use Case:
In software and systems engineering, a use case is a list of actions or event steps typically defining the interactions between a role and a system to achieve a goal. The actor can be a human or other external system.
### Class Diagram:
In software engineering, a class diagram in the Unified Modeling Language (UML) is a type of static structure diagram that describes the structure of a system by showing the system's classes, their attributes, operations (or methods), and the relationships among objects.
### Interpreter:
In Computing, an interpreter is a computer program that directly executes instructions written in a programming or scripting language. It will do this without requiring them to have been previously compilied into a machine language program. An interpreter takes less time to analyze the source code but the overall execution time is slower. A benefit of using an interpreter is that it continies translating the program until the first error is met, in which it then stops. This helps to make debugging easier as you will be able to see where the error occurred.
### Compiler:
The way a compiler works is that it scan the entire program and translates it as a whole into machine code. Ready for it to run. The problem with this is that it takes large amount of time to analyze the source code but the overall execution time is comparatively faster. Some examples of languages that use a Compiler is C or C++. Another problem with a comiler is that it generates the error message only after scanning the whole program. Hence debugging is comparatively hard.
## Types of Research:
Types of research methods can be divided into two quantitative and qualitative categories:

Quantitative research “describes, infers, and resolves problems using numbers. Emphasis is placed on the collection of numerical data, the summary of those data and the drawing of inferences from the data”[Herbst, F. & Coldwell, D. (2004) Business Research, Juta and Co Ltd, p.15].

Qualitative research, on the other hand, is based on words, feelings, emotions, sounds and other non-numerical and unquantifiable elements. It has been noted that “information is considered qualitative in nature if it cannot be analysed by means of mathematical techniques. This characteristic may also mean that an incident does not take place often enough to allow reliable data to be collected”[Herbst, F. & Coldwell, D. (2004) Business Research, Juta and Co Ltd, p.13]

There is also another form of research... Observation. Although it does not give you the same detailed results as quantative and qualative, it can offer a closer understanding than the other two, however all have their pro's and con's.

Which is best for accuracy and reliability?
In regards to which research method is best for accuracy then it is all down to personal opinion. I personally feel as though the qualitative research is the best because it gets a deeper understanding from an individual that may not have a complete understanding of what they are being used to give an answer about. Both methods have different benefits which can be used in different ways, if its numbers that you're after for your research then quantatative is the best, however if you're after a better understanding and detailed look into someones thought process then qualatative is the best.
### Technical solutions:
#### What is a technical solution?
A technical solution is where someone comes in to select, design and implement a solution to a set requirement. For instance within software development, there are going to a lot of times where you will need people to solve an issue or problem, wether its with a line of code that does not correctly work or even just a feature that you cant correctly impliment - The answer is a technical solution.
#### How can you compare technical solutions?
There are a few ways in which you can compare technical solutions:

**Difficulty** - This is how hard it is going to be to impliment the solution. For instance you may need to completely rewrite a huge area of code in order to fix an issue, or you might simply just need to change a simple variable. When it comes to software development the type of issues can be very minor and easy to fix up to very complicated and difficult to resolve.

**Time to implement** - This is how long it is either going to take to impliment the solution or solve the whole problem. Like the point above, the time it is going to take to impliment the solution all depends on the level of seriousness and how complicated the problem is. it could range from being a simple line of code that need changing which would not take long time in comparison to a a huge problem which may require a lot more than just a line or two of code being changed, this could mean it might take a long time to solve the problem.

**Skill needed** - Depending on the problem itself all depends on who you might need in order to solve the problem. It might be a case of changing a simple variable which may be able to be solved by someone already writting the software, however it could possibly be a very large problem which may require an external source who is training specifically in solving a specific problem or issue. It all depends on the problem tho on the skill that is needed to solve it.
Of course there are other ways however these are the main ones that we are going to look at.
